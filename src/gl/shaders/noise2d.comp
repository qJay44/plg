#version 460 core

layout(local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout(rgba8, binding = 0) writeonly uniform image2D imageWrite;

uniform float u_invScale;
uniform float u_persistance;
uniform float u_lacunarity;
uniform int u_octaves;
uniform int u_seed;
uniform vec2 u_offset;

float fade(float t) {
  return t*t*t*(t*(t*6.f - 15.f) + 10.f);
}

float rand(vec2 p) {
  return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453) * u_seed; // NOTE: Probably not good
}

vec2 grad(vec2 p) {
  float angle = 3.141592654f * 2.f * rand(p);
  return vec2(sin(angle), cos(angle));
}

// Returns value in [-1, 1]
float perlin(vec2 p) {
  vec2 p0 = floor(p);
  vec2 p1 = p0 + vec2(1.f, 0.f);
  vec2 p2 = p0 + vec2(0.f, 1.f);
  vec2 p3 = p0 + vec2(1.f, 1.f);

  vec2 g0 = grad(p0);
  vec2 g1 = grad(p1);
  vec2 g2 = grad(p2);
  vec2 g3 = grad(p3);

  float t0 = p.x - p0.x;
  float fade0 = fade(t0);

  float t1 = p.y - p0.y;
  float fade1 = fade(t1);

  float p0p1 = (1.f - fade0) * dot(g0, (p - p0)) + fade0 * dot(g1, (p - p1));
  float p2p3 = (1.f - fade0) * dot(g2, (p - p2)) + fade0 * dot(g3, (p - p3));

  return (1.f - fade1) * p0p1 + fade1 * p2p3;
}

void main() {
  const ivec2 texCoord = ivec2(gl_GlobalInvocationID.xy);
  const ivec2 halfSize = imageSize(imageWrite) / 2;

  const float noiseMax = u_octaves * u_persistance;
  const float noiseMin = -noiseMax;

  float amplitude = 1.f;
  float frequency = 1.f;
  float n = 0.f;

  for (int i = 0; i < u_octaves; i++) {
    vec2 sampleCoord = vec2(texCoord - halfSize) * u_invScale * frequency + u_offset;
    n += perlin(sampleCoord) * amplitude;
    amplitude *= u_persistance;
    frequency *= u_lacunarity;
  }

  n = smoothstep(noiseMin, noiseMax, n); // NOTE: Probably wrong

  imageStore(imageWrite, texCoord, vec4(vec3(n), 1.f));
}

